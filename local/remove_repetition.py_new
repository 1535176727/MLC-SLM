import argparse
import logging

from collections import Counter

def contains_global_repetition(tokens, min_repeat=10, max_ngram=3):
    for n in range(1, max_ngram + 1):
        ngrams = [' '.join(tokens[i:i+n]) for i in range(len(tokens)-n+1)]
        count = Counter(ngrams)
        if any(v >= min_repeat for v in count.values()):
            return True
    return False
    
def trim_repeated_suffix(text: str, min_repeat: int = 5, key: str = "") -> str:
    tokens = text.strip().split()
    # （可选）也可以做 collapse
    # tokens = collapse_repetition(tokens, min_repeat=30, max_ngram=2)

    # 原始句尾去重复逻辑
    max_pattern_len = min(10, len(tokens) // 2)
    for size in range(1, max_pattern_len + 1):
        pattern = tokens[-size:]
        repeat_count = 1
        i = len(tokens) - size * 2
        while i >= 0 and tokens[i:i + size] == pattern:
            repeat_count += 1
            i -= size
        if repeat_count >= min_repeat:
            new_text = tokens[:i + size] + pattern
            logging.warning(f"{key} Truncated repeated pattern x{repeat_count} → 1: {' '.join(pattern)}")
            return ' '.join(new_text)
       # 全局去重复（极端重复“で も で も”情况）
    return ' '.join(tokens)

def process_lines(input_path: str, output_path: str, min_repeat: int = 5):
    with open(input_path, 'r', encoding='utf-8') as fin, open(output_path, 'w', encoding='utf-8') as fout:
        for line in fin:
            line = line.strip()
            if not line:
                continue
            parts = line.split(maxsplit=1)
            if len(parts) != 2:
                logging.warning(f"Skipped line (format error): {line}")
                key = parts[0]
                fout.write(f"{key}\n")
                continue
            key, text = parts
            cleaned_text = trim_repeated_suffix(text, min_repeat, key)
            fout.write(f"{key} {cleaned_text}\n")
def process_lines2(input_path: str, output_path: str, min_repeat: int = 5):
    with open(input_path, 'r', encoding='utf-8') as fin, open(output_path, 'w', encoding='utf-8') as fout:
        for line in fin:
            line = line.strip()
            if not line:
                continue
            parts = line.split(maxsplit=1)
            if len(parts) != 2:
                logging.warning(f"Skipped line (format error): {line}")
                key = parts[0]
                fout.write(f"{key}\n")
                continue
            key, text = parts
            cleaned_text = text
            tokens = text.strip().split()
            if contains_global_repetition(tokens, min_repeat=30, max_ngram=3):
                logging.warning(f"{key} Removed due to global repetition")
                cleaned_text = ''

            fout.write(f"{key} {cleaned_text}\n")
def main():
    parser = argparse.ArgumentParser(description="Remove repeated suffixes from text lines.")
    parser.add_argument('--input', '-i', required=True, help="Path to input text file")
    parser.add_argument('--output', '-o', required=True, help="Path to output text file")
    parser.add_argument('--min_repeat', '-r', type=int, default=5, help="Minimum repeat count to trigger truncation")
    args = parser.parse_args()

    logging.basicConfig(level=logging.WARNING)
    process_lines(args.input, args.output+"1", args.min_repeat)
    process_lines2(args.output+"1", args.output, args.min_repeat)

if __name__ == "__main__":
    main()
